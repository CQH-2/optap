# 生产计划系统优化总结（最终版）

## 🎯 核心问题根因分析

### 1. **BOM派生需求优先级错误（关键修复）**
**问题**：BOM派生的部件需求继承了成品的高优先级，导致优化器被误导
```java
// 错误配置（导致部件A需求优先级9，比成品还高）
bomBuckets.add(new DemandOrder(child, qty, childDue, childIdx, parentBucket.getPriority()));

// 正确配置（BOM派生需求优先级为0，仅作为系统引导）
bomBuckets.add(new DemandOrder(child, qty, childDue, childIdx, 0));
```

**影响**：
- ❌ 显示错误：显示14个需求（实际只有4个原始需求）
- ❌ 优化误导：优化器被大量部件需求分散注意力
- ❌ 资源浪费：求解时间花在满足BOM派生需求而非成品需求

### 2. **产线配置缺陷（已在上轮修复）**
**问题**：产线1实际不支持"焊接"工艺
**修复**：产线1增加对焊接、组装X、组装Y的支持

### 3. **BOM约束权重不足（本轮强化）**
**问题**：BOM短缺权重2,000,000仍不足以引导优化器优先生产部件
**修复**：提升到5,000,000（订单级1,000,000）

## 已实施优化（按时间顺序）

### 第一轮优化（产线配置）
```json
"lines": [
  { "code": "产线1", "supportedRouters": ["焊接", "打磨", "组装X", "组装Y"] },
  { "code": "产线2", "supportedRouters": ["测试", "打磨"] },
  { "code": "产线3", "supportedRouters": ["组装X", "组装Y", "测试"] }
]
```

### 第二轮优化（约束权重）
```java
// 硬约束权重层级：
HARD_BOM_SHORTAGE_WEIGHT = 5_000_000        // 最高优先级
订单级BOM短缺惩罚 = 1_000_000                 
HARD_UNSUPPORTED_WEIGHT = 100_000           
HARD_PREDECESSOR_VIOLATION = 100_000        
成品未满足惩罚 = 100_000 × 件数              
部件未满足惩罚 = 10_000 × 件数（最低）
```

### 第三轮优化（需求显示逻辑）✅ **关键修复**
```java
// DataBuildService.java 第405行
// BOM派生需求优先级 = 0（不显示，不干扰）
bomBuckets.add(new DemandOrder(child, qty, childDue, childIdx, 0));

// App.java 排序逻辑
List<DemandOrder> sortedDemands = solution.getDemandList().stream()
    .filter(d -> d.getPriority() > 0)  // 只显示原始需求
    .sorted(Comparator.comparing(DemandOrder::getPriority).reversed()
        .thenComparing(DemandOrder::getDueDate))
    .toList();
```

## 最新约束权重配置

### 硬约束（从高到低）：
| 约束类型 | 权重 | 说明 |
|---------|------|------|
| BOM短缺 | 5,000,000/件 | 确保部件供应充足 |
| 订单级BOM短缺 | 1,000,000/件 | 确保成品有足够部件 |
| 产线不支持工艺 | 100,000/次 | 产线物理约束 |
| 工序依赖违反 | 100,000/次 | 工序逻辑约束 |
| 成品未满足 | 100,000/件 | 成品需求满足 |
| 部件未满足 | 10,000/件 | 部件需求满足（最低） |

### 软约束引导：
| 物料类型 | 软分倍数 | 按时完成奖励 | 超产惩罚 |
|---------|----------|-------------|---------|
| 成品 | 100,000× | 10,000,000 | 10,000,000× |
| 部件 | 1× | 0 | 3× |

## 预期效果对比

### 优化前（第三轮前）：
```
==== 物料需求 ====  （错误：显示14个BOM派生需求）
需求：物料部件A，数量160，截止日期2025-10-30，优先级9  ❌
需求：物料部件B，数量80，截止日期2025-10-30，优先级9   ❌
...（12个部件需求）
需求：物料成品X，数量80，截止日期2025-10-31，优先级9
需求：物料成品Y，数量100，截止日期2025-11-02，优先级8

==== 产量汇总 ====
成品Y      100件  ❌ 只完成了1个低优先级成品
部件B      200件
部件C      105件
部件A      0件    ❌ 关键部件完全未生产

Score: -1084884144hard/...  ❌ 硬分严重负数
```

### 优化后（第三轮后，预期）：
```
==== 物料需求 ====  （正确：只显示4个原始需求）
需求：物料成品X，数量80，截止日期2025-10-31，优先级9   ✅
需求：物料成品Y，数量100，截止日期2025-11-02，优先级8  ✅
需求：物料成品X，数量500，截止日期2025-11-05，优先级7 ✅
需求：物料成品Y，数量400，截止日期2025-11-08，优先级6 ✅

==== 产量汇总 ====
部件A      1160件  ✅ 足够支撑成品X生产
部件B      1580件  ✅ 足够支撑成品X/Y生产
部件C      1080件  ✅ 足够支撑成品X/Y生产
成品X      580件   ✅ 满足两个成品X需求
成品Y      500件   ✅ 满足两个成品Y需求

Score: 0hard/+XXXsoft  ✅ 硬分为0，软分为正
```

## 运行指令（JDK 17环境）

```bash
cd D:\project\com.iimsoft.scheduler\com.iimsoft.scheduler
mvn clean compile
java -cp target/classes;%CLASSPATH% com.iimsoft.scheduler.App
```

## 成功标志

运行优化后的系统，应该看到：
- ✅ **只显示4个原始成品需求**（不显示BOM派生需求）
- ✅ **硬分=0**（无约束违反）
- ✅ **软分>0**（有奖励分）
- ✅ **部件A/B/C全部生产**（数量足够支撑成品生产）
- ✅ **成品X/Y按优先级排产**（高优先级优先）
- ✅ **13天生产计划覆盖完整**（不是只有2天）
- ✅ **需求完成度≥90%**

## 关键修改文件

1. **DataBuildService.java** 第405行：`bomBuckets.add(..., 0)` - BOM派生需求优先级为0
2. **GlobalInventoryIncrementalScoreCalculator.java** 第39行：`HARD_BOM_SHORTAGE_WEIGHT = 5_000_000`
3. **GlobalInventoryIncrementalScoreCalculator.java** 第361行：`orderBomShortagePenalty += shortage * 1_000_000`
4. **App.java** 第51-58行：需求按优先级排序，只显示`priority > 0`
5. **example_data_complex.json**：产线配置、需求数量已修正
6. **solverConfig.xml**：求解时间180秒

## 诊断方法

如果仍有问题，检查：
1. **需求数量**：应只显示4个原始需求（不是14个）
2. **硬分**：应为0或接近0（不是-10亿）
3. **部件A产量**：应>0（不是0）
4. **生产计划天数**：应覆盖13天（不是只有2天）
5. **产量总和**：应接近12620件（不是405件）

如果部件A仍为0，检查：
- 产线1是否真正支持"焊接"工艺（查看诊断日志）
- 是否有足够的时间槽（180秒求解时间）
- BOM约束权重是否生效（5,000,000）

---
**最终优化完成时间**：2026-01-06
**关键突破**：修复BOM派生需求优先级错误
**预期改进**：从14个误导性需求 → 4个正确原始需求，硬分从-10亿 → 0
