package com.iimsoft.scheduler.rules
dialect "java"

import com.iimsoft.scheduler.domain.HourPlan
import com.iimsoft.scheduler.domain.Line
import com.iimsoft.scheduler.domain.Requirement
import com.iimsoft.scheduler.domain.Inventory
import com.iimsoft.scheduler.domain.BomComponent
import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder

global HardSoftScoreHolder scoreHolder

// 硬约束：无物料时数量必须为 0
rule "Zero quantity when no item"
when
    HourPlan(item == null, $q : quantity)
    eval($q != null && $q.intValue() > 0)
then
    scoreHolder.addHardConstraintMatch(kcontext, -$q.intValue());
end

// 硬约束：有物料则数量必须 > 0；数量 <= 0 时不能安排物料
rule "Item requires positive quantity"
when
    HourPlan(item != null, $q : quantity)
    eval($q == null || $q.intValue() <= 0)
then
    scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// 硬约束：产线必须支持该物料
rule "Line must support item"
when
    HourPlan(item != null, $line : slot.line, $item : item, eval(!$line.supportsItem($item)))
then
    scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// 硬约束（件/小时能力）：数量 ≤ 产线对该物料的“件/小时”能力
rule "Hourly quantity must not exceed units-per-hour capacity"
when
    $hp : HourPlan(item != null, $line : slot.line, $item : item, $q : quantity)
    eval($q != null && $q.intValue() > 0)
    eval($q.intValue() > $line.getUnitsPerHourForItem($item))
then
    int cap = $line.getUnitsPerHourForItem($item);
    int excess = $q.intValue() - cap;
    scoreHolder.addHardConstraintMatch(kcontext, -excess);
end

// 硬约束：按交期满足需求（到期前累积产出必须 ≥ 需求）
rule "Satisfy requirements by due date"
when
    $req : Requirement($item : item, $due : dueEndIndexMinutes, $need : quantity)
    $sum : Number() from accumulate(
        HourPlan(item == $item, $q : quantity, $end : endIndex,
                 eval($q != null && $q.intValue() > 0 && $end != null && $end.longValue() <= $due.longValue())),
        sum($q)
    )
    eval($sum.intValue() < $need)
then
    int shortage = $req.getQuantity() - $sum.intValue();
    scoreHolder.addHardConstraintMatch(kcontext, -shortage);
end

// 硬约束：装配前子件动态库存必须满足
// 可用子件 = 期初库存(Inventory) + 截至当前(含当前开始前)子件产出 − 截至当前(含当前开始前)历史装配对该子件的消耗
rule "Child inventory must be sufficient before assembly"
when
    // 当前装配（父物料）
    $plan : HourPlan(item != null, $parent : item, $q : quantity, $start : startIndex)
    eval($q != null && $q.intValue() > 0)
    // 当前装配需要的子件及其用量
    $bom : BomComponent(parentItem == $parent, $child : childItem, $per : quantityPer)

    // 期初库存（该子件）
    $inv : Number() from accumulate(
        Inventory(item == $child, $on : onHandQty),
        sum($on)
    )

    // 截至当前开始时刻（<= start）该子件累计产出
    $prod : Number() from accumulate(
        HourPlan(item == $child, $pq : quantity, $pend : endIndex,
                 eval($pq != null && $pq.intValue() > 0
                      && $pend != null && $pend.longValue() <= $start.longValue())),
        sum($pq)
    )

    // 截至当前开始时刻（<= start）历史装配对该子件的累计消耗
    $cons : Number() from accumulate(
        BomComponent(childItem == $child, $p2 : parentItem, $per2 : quantityPer) and
        HourPlan(item == $p2, $cq : quantity, $cend : endIndex,
                 eval($cq != null && $cq.intValue() > 0
                      && $cend != null && $cend.longValue() <= $start.longValue())),
        sum($cq.intValue() * $per2)
    )

    // 若可用子件不足以支撑本次装配用量，则违规（大罚可按需调大）
    eval( ($inv.intValue() + $prod.intValue() - $cons.intValue()) < ($q.intValue() * $per) )
then
    scoreHolder.addHardConstraintMatch(kcontext, -10000);
end

