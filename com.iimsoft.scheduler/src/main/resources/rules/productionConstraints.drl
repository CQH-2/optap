package com.iimsoft.scheduler.rules
dialect "java"

import com.iimsoft.scheduler.domain.TaskPart
import com.iimsoft.scheduler.domain.Router
import com.iimsoft.scheduler.domain.Line
import com.iimsoft.scheduler.domain.LineShiftSlot
import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder
import java.util.Set

global HardSoftScoreHolder scoreHolder

// 硬约束：选定槽位的产线必须支持所选工艺
rule "Line must support router"
when
    TaskPart(slot != null, router != null, $slot : slot, $router : router, eval(!$slot.getLine().supports($router)))
then
    scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// 硬约束：工艺必须支持该物料
rule "Router must support item"
when
    TaskPart(router != null, $router : router, $item : item, eval(!$router.supports($item)))
then
    scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// 硬约束：槽位分钟容量不能超（sum(requiredMinutes) ≤ slot.durationMinutes）
rule "Slot time capacity must not be exceeded"
when
    $slot : LineShiftSlot()
    $sum : Number() from accumulate(
        TaskPart(slot == $slot, $req : requiredMinutes),
        sum($req)
    )
    eval($sum.intValue() > ($slot.getEndMinuteOfDay() - $slot.getStartMinuteOfDay()))
then
    int duration = $slot.getEndMinuteOfDay() - $slot.getStartMinuteOfDay();
    int over = $sum.intValue() - duration;
    scoreHolder.addHardConstraintMatch(kcontext, -over);
end

// 硬约束：同一槽位内禁止混工艺（一个槽位只能跑一种 Router）
rule "Single router per slot (no mixing within a slot)"
when
    $slot : LineShiftSlot()
    $routerSet : Set() from accumulate(
        TaskPart(slot == $slot, router != null, $r : router),
        collectSet($r)
    )
    eval($routerSet.size() > 1)
then
    int overKinds = $routerSet.size() - 1;
    scoreHolder.addHardConstraintMatch(kcontext, -overKinds);
end

// 软约束：交期迟期惩罚（从 TaskPart.task 读取交期）
rule "Minimize tardiness (due date)"
when
    TaskPart(slot != null, $end : slot.endIndex, $due : task.dueEndIndexMinutes)
    eval($due != null && $end > $due.longValue())
then
    int late = (int)($end - $due.longValue());
    scoreHolder.addSoftConstraintMatch(kcontext, -late);
end

// 软约束：夜班惩罚（让系统“优先白班，容量不够时才用夜班”）
// 简化判断：开始时间 >= 18:00 视为夜班。可根据你的实际班次字段替换。
rule "Penalize night shift usage"
when
    TaskPart(slot != null, $startMin : slot.startMinuteOfDay, eval($startMin >= (18 * 60)))
then
    scoreHolder.addSoftConstraintMatch(kcontext, -100); // 权重可调
end

// 软约束：同一条产线的负载尽量均衡（平方惩罚）
rule "Balance line load"
when
    $line : Line()
    $sum : Number() from accumulate(
        TaskPart(slot != null, $line == getLine(), $q : quantity),
        sum($q)
    )
then
    int load = $sum.intValue();
    scoreHolder.addSoftConstraintMatch(kcontext, -(load * load));
end